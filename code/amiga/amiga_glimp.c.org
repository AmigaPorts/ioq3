/*
===========================================================================
Copyright (C) 1999-2005 Id Software, Inc.

This file is part of Quake III Arena source code.

Quake III Arena source code is free software; you can redistribute it
and/or modify it under the terms of the GNU General Public License as
published by the Free Software Foundation; either version 2 of the License,
or (at your option) any later version.

Quake III Arena source code is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Foobar; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
===========================================================================
*/

#include "../renderer/tr_local.h"
#include "../client/client.h"
#include "amiga_local.h"

#include <proto/exec.h>
#include <proto/intuition.h>
#include <GL/gl.h>

struct GLContextIFace *context = 0;
extern struct MiniGLIFace *IMiniGL;

extern qboolean mouse_active;
extern int mx, my;

extern cvar_t *r_finish;
cvar_t *r_closeworkbench;

extern cvar_t *in_nograb;

static UWORD mousePtr = 0;

extern struct MsgPort *Sys_EventPort;

void (APIENTRYP qglActiveTextureARB) (GLenum texture);
void (APIENTRYP qglClientActiveTextureARB) (GLenum texture);
void (APIENTRYP qglMultiTexCoord2fARB) (GLenum target, GLfloat s, GLfloat t);

void (APIENTRYP qglLockArraysEXT) (GLint first, GLsizei count);
void (APIENTRYP qglUnlockArraysEXT) (void);


void GLimp_RenderThreadWrapper( void *stub ) 
{
}

qboolean GLimp_SpawnRenderThread( void (*function)( void ) ) 
{
	ri.Printf( PRINT_WARNING, "ERROR: SMP support was disabled at compile time\n");
	return qfalse;
}

void *GLimp_RendererSleep( void ) 
{
	return NULL;
}

void GLimp_FrontEndSleep( void ) 
{
}

void GLimp_WakeRenderer( void *data ) 
{
}

void GLimp_SetGamma( unsigned char red[256], unsigned char green[256], unsigned char blue[256] )
{
}

void GLW_InitGamma(void)
{
}

void GLW_RestoreGamma(void)
{
}

static qboolean GLW_StartDriverAndSetMode( const char *drivername, 
										   int mode, 
										   int colorbits,
										   qboolean fullscreen )
{
	BOOL useStencil = TRUE;
	
	ri.Printf(PRINT_ALL, "...setting mode %d:", mode);
	
	if (!R_GetModeInfo( &glConfig.vidWidth, &glConfig.vidHeight, &glConfig.windowAspect, mode))
	{
		ri.Printf(PRINT_ALL, " invalid mode\n");
		return qfalse;
	}
	
	if (glConfig.hardwareType == GLHW_3DFX_2D3D)
		useStencil = FALSE;
	
	if (colorbits != 16)
		colorbits = 24;
	
	ri.Printf( PRINT_ALL, " %d %d %s\n", glConfig.vidWidth, glConfig.vidHeight, fullscreen ? "fullscreen" : "windowed" );
	
	if (context)
		context->DeleteContext();
		
	context = IMiniGL->CreateContextTags(
			MGLCC_Width,                    glConfig.vidWidth,
			MGLCC_Height,                   glConfig.vidHeight,
			MGLCC_TextureBufferSize,		65536,
			MGLCC_NoMipMapping,				FALSE,
			MGLCC_Windowed,                 !fullscreen,
			MGLCC_Buffers,                  3,
			MGLCC_PixelDepth,               colorbits,
			MGLCC_CloseGadget,              FALSE /*TRUE*/,
			MGLCC_SizeGadget,               FALSE /*TRUE*/,
			MGLCC_StencilBuffer,			useStencil,
		TAG_DONE);

	if (!context)
	{
		ri.Printf(PRINT_ALL, "Error creating GL context\n");
		return qfalse;
	}
	
	mglMakeCurrent(context);
	mglLockMode(MGL_LOCK_SMART);
	if (r_finish)
		mglEnableSync(r_finish->integer);
	else
		mglEnableSync(GL_TRUE);
	
	IIntuition->ModifyIDCMP((struct Window *)mglGetWindowHandle(),
			IDCMP_RAWKEY|IDCMP_MOUSEMOVE|IDCMP_MOUSEBUTTONS|IDCMP_DELTAMOVE
			|IDCMP_EXTENDEDMOUSE|IDCMP_EXTENDEDKEYBOARD);

	Sys_EventPort = ((struct Window *)mglGetWindowHandle())->UserPort;
	ri.Printf(PRINT_ALL, "... Sys_EventPort at %p\n", Sys_EventPort);
	
	glConfig.colorBits = colorbits;
	
	if (glConfig.hardwareType == GLHW_3DFX_2D3D)
	{
		glConfig.depthBits = 16;
		glConfig.stencilBits = 0;
	}
	else
	{
		glConfig.depthBits = 16;
		glConfig.stencilBits = 8;
	}
	
	glConfig.isFullscreen = fullscreen;
	
	r_closeworkbench = Cvar_Get("r_closeworkbench", "0", CVAR_ARCHIVE);
	if (fullscreen && r_closeworkbench->value)
		IIntuition->CloseWorkBench();  // TODO: is this really wanted...?

	return qtrue;
}
	
static void GLW_Shutdown(void)
{
	if (context)
	{
		context->DeleteContext();
		context = 0;
		
		mglMakeCurrent(0);
		Sys_EventPort = 0;
	}
}
static qboolean GLW_LoadOpenGL(const char *name)
{
	qboolean fullscreen;
	
	ri.Printf( PRINT_ALL, "...loading %s\n", name);
	
	if (QGL_Init(name))
	{
		fullscreen = r_fullscreen->integer;
		
		if (!GLW_StartDriverAndSetMode(name, r_mode->integer, r_colorbits->integer, fullscreen))
		{
			if (r_mode->integer != 3)
			{
				if (!GLW_StartDriverAndSetMode(name, 3, r_colorbits->integer, fullscreen))
				{
					QGL_Shutdown();
					return qfalse;
				}
			}
		}
		
		return qtrue;
	}
	
	ri.Printf(PRINT_ALL, "failed\n");
	
	QGL_Shutdown();
	
	return qfalse;
}


void GLW_StartOpenGL(void)
{
	GLW_LoadOpenGL("minigl.library");
}


static void GLW_InitExtensions( void )
{
	if ( !r_allowExtensions->integer )
	{
		ri.Printf( PRINT_ALL, "*** IGNORING OPENGL EXTENSIONS ***\n" );
		return;
	}

	ri.Printf( PRINT_ALL, "Initializing OpenGL extensions\n" );

	// GL_S3_s3tc
	glConfig.textureCompression = TC_NONE;
	if ( strstr( glConfig.extensions_string, "GL_S3_s3tc" ) )
	{
		if ( r_ext_compressed_textures->integer )
		{
			glConfig.textureCompression = TC_S3TC;
			ri.Printf( PRINT_ALL, "...using GL_S3_s3tc\n" );
		}
		else
		{
			glConfig.textureCompression = TC_NONE;
			ri.Printf( PRINT_ALL, "...ignoring GL_S3_s3tc\n" );
		}
	}
	else
	{
		ri.Printf( PRINT_ALL, "...GL_S3_s3tc not found\n" );
	}

	// GL_EXT_texture_env_add
	glConfig.textureEnvAddAvailable = qfalse;
	if ( strstr( glConfig.extensions_string, "EXT_texture_env_add" ) )
	{
		if ( r_ext_texture_env_add->integer )
		{
			glConfig.textureEnvAddAvailable = qtrue;
			ri.Printf( PRINT_ALL, "...using GL_EXT_texture_env_add\n" );
		}
		else
		{
			glConfig.textureEnvAddAvailable = qfalse;
			ri.Printf( PRINT_ALL, "...ignoring GL_EXT_texture_env_add\n" );
		}
	}
	else
	{
		ri.Printf( PRINT_ALL, "...GL_EXT_texture_env_add not found\n" );
	}

	// GL_ARB_multitexture
	if ( strstr( glConfig.extensions_string, "GL_ARB_multitexture" )  )
	{
		if ( r_ext_multitexture->integer )
		{
			if ( 1 )
			{
				//qglGetIntegerv( GL_MAX_TEXTURE_UNITS_ARB/*GL_MAX_ACTIVE_TEXTURES_ARB*/, &glConfig.maxActiveTextures );
				GLint glint = 0;
				qglGetIntegerv( GL_MAX_TEXTURE_UNITS_ARB, &glint );
				glConfig.numTextureUnits = (int) glint;
				
				if ( glConfig.numTextureUnits > 1 )
				{
					qglMultiTexCoord2fARB = &glMultiTexCoord2f;
					qglActiveTextureARB = &glActiveTexture;
					qglClientActiveTextureARB = glClientActiveTexture;
					
					ri.Printf( PRINT_ALL, "...using GL_ARB_multitexture\n" );
				}
				else
				{
					qglMultiTexCoord2fARB = NULL;
					qglActiveTextureARB = NULL;
					qglClientActiveTextureARB = NULL;
					ri.Printf( PRINT_ALL, "...not using GL_ARB_multitexture, < 2 texture units\n" );
				}
			}
		}
		else
		{
			ri.Printf( PRINT_ALL, "...ignoring GL_ARB_multitexture\n" );
		}
	}
	else
	{
		ri.Printf( PRINT_ALL, "...GL_ARB_multitexture not found\n" );
	}

	// GL_EXT_compiled_vertex_array
	if ( strstr( glConfig.extensions_string, "GL_EXT_compiled_vertex_array" ) && ( glConfig.hardwareType != GLHW_RIVA128 ) )
	{
		if ( r_ext_compiled_vertex_array->integer )
		{
			qglLockArraysEXT = &glLockArraysEXT;
			qglUnlockArraysEXT = glUnlockArraysEXT;
 
			ri.Printf( PRINT_ALL, "...using GL_EXT_compiled_vertex_array\n" );
		}
		else
		{
			ri.Printf( PRINT_ALL, "...ignoring GL_EXT_compiled_vertex_array\n" );
		}
	}
	else
	{
		ri.Printf( PRINT_ALL, "...GL_EXT_compiled_vertex_array not found\n" );
	}
}

void GLimp_Init(void)
{
	char buf[1024];
	ri.Printf(PRINT_ALL, "Initializing OpenGL subsystem\n");

	GLW_StartOpenGL();

	// get our config strings
	Q_strncpyz( glConfig.vendor_string, qglGetString (GL_VENDOR), sizeof( glConfig.vendor_string ) );
	Q_strncpyz( glConfig.renderer_string, qglGetString (GL_RENDERER), sizeof( glConfig.renderer_string ) );
	Q_strncpyz( glConfig.version_string, qglGetString (GL_VERSION), sizeof( glConfig.version_string ) );
	Q_strncpyz( glConfig.extensions_string, qglGetString (GL_EXTENSIONS), sizeof( glConfig.extensions_string ) );

	//
	// chipset specific configuration
	//

	Q_strncpyz( buf, glConfig.renderer_string, sizeof(buf) );
	Q_strlwr( buf );

	glConfig.driverType = GLDRV_ICD;
	glConfig.hardwareType = GLHW_GENERIC;

	if ( strstr( buf, "voodoo avenger" ) )
	{
		glConfig.hardwareType = GLHW_3DFX_2D3D;
	}
	
	if ( strstr( buf, "permedia2" ) )
	{
		glConfig.hardwareType = GLHW_PERMEDIA2;
	}
	
	GLW_InitExtensions();
	GLW_InitGamma();

	if (!glConfig.isFullscreen)
	{
		// Clear the mouse pointer in window mode
		mousePtr = IExec->AllocVec( 8, MEMF_CHIP|MEMF_CLEAR );
		if (mousePtr)
		{
			IIntuition->SetPointer( (struct Window *)mglGetWindowHandle(), mousePtr, 0, 0, 0, 0 );
		}
	}

}

void GLimp_Shutdown(void)
{
	/* TODO: does MiniGL showhow free the pointer automatically because this gives guru
	if (mousePtr)
	{
		IExec->FreeVec(mousePtr);
		mousePtr = 0;
	}
	*/
	
	GLW_RestoreGamma();
	GLW_Shutdown();
	QGL_Shutdown();
	
	memset( &glConfig, 0, sizeof( glConfig ) );
	memset( &glState, 0, sizeof( glState ) );
}


void GLimp_LogComment( char *comment ) 
{
//	if ( glw_state.log_fp )
//	{
//		fprintf( glw_state.log_fp, "%s", comment );
//	}
}

void GLimp_EndFrame(void)
{
	//Com_Printf("EndFrame...\n");

	if (r_finish->modified)
	{
		mglEnableSync(r_finish->integer);
		r_finish->modified = qfalse;
	}
	
	mglUnlockDisplay();
	//Com_Printf("switch\n");
	mglSwitchDisplay();
	//Com_Printf("...EndFrame\n");

	if (!r_fullscreen->integer && !in_nograb->integer)
	{
		static uint32 lastGrab = 0;
		uint32 now;

		// Capture the pointer in window mode, unless user wants nograb!
		now = Sys_Milliseconds();

		if (now - lastGrab > 1000)
		{
			IIntuition->SetWindowAttrs((struct Window *) mglGetWindowHandle(), WA_GrabFocus, 100, TAG_DONE);
			lastGrab = now;
		}
	} 
}

void install_grabs (void)
{
	mglGrabFocus(GL_TRUE);
	mouse_active = qfalse;
}

void uninstall_grabs (void)
{
	mglGrabFocus(GL_FALSE);
		
	mx = 0;
	my = 0;
	mouse_active = qtrue;
}
